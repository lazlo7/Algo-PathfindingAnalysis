# Особенности тестирования

Тестирование проводилось на платформе Linux с включенным флагом оптимизации компилятора `-O3`.  
Каждый алгоритм тестируется с временными замерами `<test_repeat_count>` раз на одних и тех же входных данных (граф, начальная и конечная точки). Результаты замеров суммируются и затем усредняются.  
Стоит заметить, что выбор начальной и конечной точки пути может значительно влиять на временные замеры алгоритмов из-за равномерно-случайного выбора двух точек на графе. Это может исказить итоговые замеры, демонстрируя, что один и тот же алгоритм якобы работает эффективнее на графах большего размера, в итоге приводя к так называем, скачкам на графе. Чтобы противостоять этому, программа для одного и того же графа, будет генерировать `<endpoints_generation_repeat_count>` пар начальной и конечной точек. При этом все алгоритмы нахождения кратчайшего пути будут использовать те же самые точки для данного графа. Итоговые замеры для каждого алгоритма получаются путем усреднения замера для каждой пары начальной и конечной точек.  
Использование `<test_repeat_count>` и `<endpoints_generation_repeat_count>` позволяет *сгладить* итоговые замеры и получить демонстрацию эффективности алгоритмов *в среднем*.  
По умолчанию, `<test_repeat_count> = 10` и `<endpoints_generation_repeat_count> = 10`.    
Значения `<test_repeat_count>` `<endpoints_generation_repeat_count>` для тестирования остались выбраны по-умолчанию программой.  

# Асимптотический обзор реализованных алгоритмов
В среднем на случайных графах:  
|    Алгоритм    |    Сложность      |
|----------------|-------------------|
|    Дейкстра    |`O(\|V\|^2)`       |
|  Флойд-Уоршелл |`Theta(\|V\|^3\|)` |
|  Форд-Беллман  |`O(\|E\|\|V\|)`    |
|      SPFA      |`O(\|E\|)`         |        

# Результаты тестирования

## Один алгоритм - много типов графов
Алгоритм Флойда-Уоршелла показывает себя наиболее стабильно на разных типах графов на графике с числом вершин. Все 3 типа графов растут почти одинаково. Неудивительно, ведь алгоритм Флойда-Уоршелла точно оценивается как `Theta(\|V\|^3\|)` и, соответственно не зависит от данных типов графов, которые влияют на число ребер. На графике с числом ребер, три линии сильно разделены между собой. Это связано с тем, что число ребер однозначно определяется числом вершин (за исключением связных графов, где плотность может варьироваться от 0.4 до 0.5, однако это все равно не большие изменения): для полных графов: `|E| = |V|(|V| - 1) * 0.5`, для разреженных графов (деревьев): `|E| = |V| - 1`, для связных графов: `|E| = |V|(|V| - 1) * 0.5 * density`. Так, для деревьев число вершин почти равно числу ребер, а так как Флойд-Уоршелл кубически зависит от числа вершин, то на графике с числом ребер, линия разреженных графов будет очень быстро расти, что и видно на графике - это почти прямая линия вверх. Аналогично для полных и связных графов, за счет связи числа ребер и числа вершин, линии, на самом деле, показывают результаты соответствующие графику с числом вершин. Из оценки алгоритма, следует, что он лучше всего работает на графах с маленьким числом вершин (в данном случае на разреженных графах, что и подтверждается графиками).  

Алгоритм Дейкстры показывает хорошие результаты для всех типов графов, что и должно следовать из его сложности. Линяя разреженных графов почти не растет на графике с числом вершин. На графике с числом ребер, кажется, что линия разреженных графов выродилась в точку, что почти правильно, ведь число ребер на деревьях намного меньше в сравнении с полными графами или связными графами с тем же числом вершин.  

Алгоритм Беллмана-Форда показывает худшую эффективность в сравнении с другими алгоритмами для полных и связных графов. Неудивительно, ведь алгоритм зависит как от числа вершин, так и от числе ребер и на графах с большим числом ребер (такие как, полные и связные графы) должен показывать плохую эффективность. Однако, на разреженных графах алгоритм работает быстро, равняясь с алгоритмом Дейкстры. Это связано, что сложность алгоритма вырождается в `O(|V|^2)` за счет `|E| ~ |V|`, что соответствует сложности алгоритма Дейкстры. На графике с числом ребер линяя разреженных графов вырождается в точку, как и в алгоритме Дейкстры.  

SPFA показывает лучшие результаты по сравнению с остальными алгоритмами, что и должно следовать из его сложности. На графике с числом ребер наблюдается линейная зависимость времени от числа ребер. Стоит заметить, что длина некоторых линий типов графов ограничена за счет того, что максимальное число ребер сильно варьируется для разных видов графов.  

## Один тип графа - много алгоритмов
На графике с разреженными графами видно, что все алгоритмы, за исключением Флойда-Уорешлла, демонстрируют отличные, почти одинаковые, результаты. Это связано с кубической точной сложностью алгоритма Флойда-Уоршелла. 

На графике с связными графами видно, что лучшую эффективность демонстрируют SPFA и алгоритм Дейкстры. Форд-Беллман же растет кубически, за счет того, что `|E|` в сложности превращается в `|V|(|V| - 1) * 0.5 * denisty`, что ведет к кубической сложности алгоритма.

На графике с полными графами видно, что лучшую эффективность опять демонстрируют SPFA и алгоритм Дейкстры. Данный график похож на график с связными графами, ведь формула числа ребер остается той же, за исключением отсутствия константы плотности. Аналогично, Форд-Беллман растет кубически.

# Выводы
- Алгоритм Дейкстры, алгоритм Форда-Беллмана и SPFA лучше всего работают на связных графах;
- Алгоритм Дейкстры, алгоритм Форда-Беллмана и SPFA хуже всего работают на полных графах;
- Алгоритм Флойда-Уоршелла работает примерно одинаково плохо на всех трех типах графов;
- На всех типах графов, лучше всего работают алгоритм Дейкстры и SPFA;
- На полных и связных графах хуже всего работает алгоритм Беллмана-Форда;
- На разреженном графе алгоритм Дейкстры, алгоритм Форда-Беллмана и SPFA работают почти одинаково отлично;
- На разреженном графе хуже всего работает алгоритм Флойда-Уоршелла (с большим отрывом) и растет кубически. 
  